use std::collections::BTreeSet;
use std::fs;
use std::process::Command;

use anyhow::{Result, bail};
use surrealdb::{Surreal, engine::any::Any};
use time::{OffsetDateTime, format_description::well_known::Rfc3339, macros::format_description};

use crate::db_capabilities::supports_remove_api;
use crate::schema_state::{
	FileDiff, MIGRATIONS_DIR, SchemaFile, build_catalog_snapshot, collect_schema_files,
	diff_schema, ensure_local_state_dirs, load_catalog_snapshot, load_schema_snapshot,
	removed_entities, render_remove_sql, save_catalog_snapshot, save_schema_snapshot,
	snapshot_from_files,
};

#[derive(Debug, Clone)]
pub struct CommitOpts {
	pub name: Option<String>,
	pub dry_run: bool,
	pub allow_empty: bool,
}

pub async fn run_commit(db: &Surreal<Any>, opts: CommitOpts) -> Result<()> {
	ensure_local_state_dirs()?;
	warn_branch_staleness();

	let files = collect_schema_files()?;
	let old_schema = load_schema_snapshot()?;
	let old_catalog = load_catalog_snapshot()?;
	let new_schema = snapshot_from_files(&files);
	let new_catalog = build_catalog_snapshot(&files);

	let file_diff = diff_schema(&old_schema, &new_schema);
	let removed = removed_entities(&old_catalog, &new_catalog);

	if !file_diff.removed.is_empty() && removed.is_empty() {
		bail!(
			"Schema files were removed but no removable entities were inferred. \
Create an explicit manual migration for destructive changes."
		);
	}

	let api_supported = if removed.iter().any(|e| e.kind == "api") {
		supports_remove_api(db).await?
	} else {
		true
	};
	let remove_sql = render_remove_sql(&removed, api_supported)?;

	let changed_files = changed_files(&files, &file_diff);
	let has_changes = !changed_files.is_empty() || !remove_sql.is_empty();

	if !has_changes {
		if opts.allow_empty {
			println!("No schema changes detected; snapshots already up to date.");
			return Ok(());
		}
		bail!("No schema changes detected.");
	}

	let migration_name = opts.name.as_deref().unwrap_or("schema_update");
	let migration_slug = slugify(migration_name);
	let ts = OffsetDateTime::now_utc().format(&format_description!(
		"[year][month][day][hour][minute][second]"
	))?;
	let now = OffsetDateTime::now_utc().format(&Rfc3339)?;
	let migration_file = format!("{MIGRATIONS_DIR}/{ts}__{migration_slug}.surql");
	let migration_sql = build_migration_sql(
		&now,
		&file_diff,
		&changed_files,
		&remove_sql,
		file_diff.removed.len(),
	)?;

	if opts.dry_run {
		println!("Pending migration changes detected:");
		println!(
			"  files: +{} ~{} -{}",
			file_diff.added.len(),
			file_diff.modified.len(),
			file_diff.removed.len()
		);
		println!("  stale entities to remove: {}", remove_sql.len());
		println!("  would create: {}", migration_file);
		bail!("dry-run detected pending schema migration/snapshot updates");
	}

	fs::write(&migration_file, migration_sql)?;
	save_schema_snapshot(&new_schema)?;
	save_catalog_snapshot(&new_catalog)?;

	println!("Generated migration {}", migration_file);
	println!("Updated schema snapshots in database/.surrealkit");

	Ok(())
}

fn changed_files<'a>(files: &'a [SchemaFile], diff: &FileDiff) -> Vec<&'a SchemaFile> {
	let changed: BTreeSet<&str> = diff
		.added
		.iter()
		.chain(diff.modified.iter())
		.map(String::as_str)
		.collect();

	let mut out: Vec<&SchemaFile> = files
		.iter()
		.filter(|f| changed.contains(f.path.as_str()))
		.collect();
	out.sort_by(|a, b| a.path.cmp(&b.path));
	out
}

fn build_migration_sql(
	timestamp: &str,
	diff: &FileDiff,
	changed_files: &[&SchemaFile],
	remove_sql: &[String],
	removed_file_count: usize,
) -> Result<String> {
	if changed_files.is_empty() && remove_sql.is_empty() {
		bail!("cannot build migration without changes");
	}

	let mut out = String::new();
	out.push_str("--- Generated by surrealkit commit\n");
	out.push_str(&format!("--- Generated at: {}\n", timestamp));
	out.push_str(&format!(
		"--- File diff: +{} ~{} -{}\n\n",
		diff.added.len(),
		diff.modified.len(),
		diff.removed.len()
	));

	if !changed_files.is_empty() {
		out.push_str("--- Schema definitions (added/modified)\n");
		for file in changed_files {
			out.push_str(&format!("--- source: {} ({})\n", file.path, file.hash));
			out.push_str(file.sql.trim());
			if !file.sql.trim_end().ends_with(';') {
				out.push(';');
			}
			out.push_str("\n\n");
		}
	}

	if !remove_sql.is_empty() {
		out.push_str("--- Stale entity removals inferred from catalog diff\n");
		for stmt in remove_sql {
			out.push_str(stmt);
			out.push('\n');
		}
		out.push('\n');
	}

	if removed_file_count > 0 && remove_sql.is_empty() {
		out.push_str("--- NOTE: files were removed but no managed entities were inferred.\n");
		out.push_str("--- Add manual REMOVE statements if needed.\n\n");
	}

	Ok(out)
}

fn slugify(input: &str) -> String {
	let mut out = String::new();
	let mut prev_dash = false;
	for ch in input.chars() {
		let c = ch.to_ascii_lowercase();
		if c.is_ascii_alphanumeric() {
			out.push(c);
			prev_dash = false;
		} else if !prev_dash {
			out.push('_');
			prev_dash = true;
		}
	}
	let trimmed = out.trim_matches('_');
	if trimmed.is_empty() {
		"schema_update".to_string()
	} else {
		trimmed.to_string()
	}
}

fn warn_branch_staleness() {
	let has_origin_main = Command::new("git")
		.args(["rev-parse", "--verify", "origin/main"])
		.output()
		.map(|o| o.status.success())
		.unwrap_or(false);

	if has_origin_main {
		let up_to_date = Command::new("git")
			.args(["merge-base", "--is-ancestor", "origin/main", "HEAD"])
			.status()
			.map(|s| s.success())
			.unwrap_or(true);
		if !up_to_date {
			eprintln!(
				"warning: branch may be stale versus origin/main; migration snapshots could require rebase."
			);
		}
	}

	let dirty_snapshots = Command::new("git")
		.args([
			"status",
			"--porcelain",
			"--",
			"database/.surrealkit/schema_snapshot.json",
			"database/.surrealkit/catalog_snapshot.json",
		])
		.output()
		.ok()
		.and_then(|o| String::from_utf8(o.stdout).ok())
		.map(|s| !s.trim().is_empty())
		.unwrap_or(false);

	if dirty_snapshots {
		eprintln!("warning: snapshot files already have uncommitted changes.");
	}
}
